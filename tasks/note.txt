Как работает вектор:

1. size и capacity через инит лист равны и равны размеру этого инит листа
2. Если конструктор принимает ссылку на другой объект, то размер текущего объекта равен размеру другого объекта, а capacity текущего объекта равен capacity другого объекта
3. Если operator= принимает ссылку на другой объект, то 
    если объект пустой, то вызываем метод clear и обнуляем указатель
    size = other.size
    capacity = other.capacity
4. Если конструктор принимает размер и массив, то
    size = size
    capacity = size
5. Метод reserve
    принимает в качестве аргумента новый capacity
    если новый capacity больше текущего, то берем максимум из new_cap и capacity*2
    после этого инициируем new_data(new_cap) и копируем в него значения из начального вектора и свопаем
    после этого capacity = new_cap
6. Метод resize
    Принимает new_size
    Если new_size больше чем capacity у текущего объекта, то берем максимум из new_size и capacity * 2 и записываем это в new_cap, после этого reserve
    Если size текущего объекта больше, чем new_size, то size = new_size
    Далее пройдемся по тем элементам, которые только что перешли в текущий объект и запустим для них конструктор, чтобы они принадлежали к классу текущего объекта
    size = new_size
7. Метод insert
    Принимает const_iterator where, T&& value / const T& value
    Идея метода - вставить элемент value в вектор в позицию where
    Если capacity = 0, то резервировать на 1 элемент
    Если size == capacity, то capacity *= 2
    Дальше надо создать вектор temp_data c capacity, перетаскиваем в него элементы текущего вектора
    temp_data[index] = value и указатель на следующий после него элемент
    Если тот элемент, на который теперь указывает ptr_td, не является последним, то заполняем temp_data из текущего вектора
    свопаем temp_data в дату текущего объекта и увеличиваем непонятно зачем размер на 1
    возвращаем итератор на бегин + индекс, ну потому что мы туда вставили элемент
8. Метод push_back
    Это инсерт в конец массива
    принимает value
9. Метод erase
    Принимает iterator where
    соответственно находим индекс
    элементы с index + 1 до size-1 муваем на 1 единицу влево, так как мы удаляем только один элемент
    возвращаем итератор на index, ну а так как элемент мы удалили, то это будет элемент, который следует за тем, который хотим удалить